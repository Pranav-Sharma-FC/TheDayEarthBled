//Weapons for the aircraft

using System;
using System.Collections.Generic;
using System.Numerics; // for Vector2 (add System.Numerics reference if needed)
using System.Threading;

namespace WeaponDemo
{
    // Simple interface for weapons
    public interface IWeapon
    {
        string Name { get; }
        float Cooldown { get; }      // seconds between shots
        bool CanFire { get; }
        void Fire(Target target);
        void Update(float deltaTime); // called every simulation tick
    }

    // Simple target class used by weapons
    public class Target
    {
        public Vector2 Position { get; set; }
        public float Health { get; set; } = 100;
        public bool IsAirborne { get; set; } = false;

        public Target(Vector2 pos, bool airborne = false)
        {
            Position = pos;
            IsAirborne = airborne;
        }
    }

    // Base weapon providing cooldown tracking
    public abstract class WeaponBase : IWeapon
    {
        public string Name { get; protected set; }
        public float Cooldown { get; protected set; }
        protected float timeUntilReady = 0f;

        public bool CanFire => timeUntilReady <= 0f;

        public virtual void Fire(Target target)
        {
            if (!CanFire)
            {
                Console.WriteLine($"{Name} is reloading ({timeUntilReady:F2}s left).");
                return;
            }

            timeUntilReady = Cooldown;
        }

        public virtual void Update(float deltaTime)
        {
            if (timeUntilReady > 0f)
                timeUntilReady -= deltaTime;
        }
    }

    // Missile — homing projectile with splash damage
    public class Missile : WeaponBase
    {
        public float Damage { get; private set; }
        public float Speed { get; private set; }
        public float SplashRadius { get; private set; }

        public Missile()
        {
            Name = "Missile";
            Cooldown = 2.0f;
            Damage = 80;
            Speed = 50;
            SplashRadius = 3.0f;
        }

        public override void Fire(Target target)
        {
            base.Fire(target);
            if (!CanFire) return; // base.Fire set cooldown; re-check not strictly necessary

            Console.WriteLine($"{Name} launched toward target at {target.Position}. (Homing)");
            // In a real game you'd spawn a projectile object; here we just simulate immediate hit for demo:
            SimulateHit(target);
        }

        private void SimulateHit(Target target)
        {
            // simple hit simulation
            Console.WriteLine($"Missile hits near {target.Position}, dealing {Damage} damage and {SplashRadius} splash.");
            target.Health -= Damage;
            if (target.Health <= 0) Console.WriteLine("Target destroyed by missile!");
            else Console.WriteLine($"Target health: {target.Health:F1}");
        }
    }

    // Laser — instant-hit beam with overheat/energy mechanic
    public class Laser : WeaponBase
    {
        public float DamagePerSecond { get; private set; }
        public float Energy { get; private set; }
        public float MaxEnergy { get; private set; }
        public float EnergyPerSecond { get; private set; } // cost while firing
        private bool isFiring = false;

        public Laser()
        {
            Name = "Laser";
            Cooldown = 0.1f; // can try to fire often but uses energy
            DamagePerSecond = 40f;
            MaxEnergy = 5f;
            Energy = MaxEnergy;
            EnergyPerSecond = 1.5f;
        }

        public override void Fire(Target target)
        {
            if (Energy <= 0)
            {
                Console.WriteLine($"{Name} has overheated / depleted energy.");
                return;
            }

            // Start continuous firing for one tick (simulation)
            isFiring = true;
            Console.WriteLine($"{Name} fires a beam at {target.Position}.");
            // Apply damage for a single frame (in real game you'd apply per-second in Update)
            float damageThisTick = DamagePerSecond * 0.1f; // assuming 0.1s tick for this demo
            target.Health -= damageThisTick;
            Energy -= EnergyPerSecond * 0.1f;
            Console.WriteLine($"Dealt {damageThisTick:F1} dmg. Energy left: {Energy:F2}");
            if (target.Health <= 0) Console.WriteLine("Target destroyed by laser!");
            base.Fire(target);
        }

        public override void Update(float deltaTime)
        {
            base.Update(deltaTime);
            if (isFiring)
            {
                // if we were in continuous fire mode, drain more energy (for demo we turn it off immediately)
                isFiring = false;
            }
            else
            {
                // recharge energy when not firing
                Energy = MathF.Min(MaxEnergy, Energy + 0.5f * deltaTime);
            }
        }
    }

    // LAAA — Laser Anti-Aircraft Artillery
    // Designed to be effective vs airborne targets, burst-fire with tracking
    public class LAAA : WeaponBase
    {
        public float BurstCount { get; private set; }
        public float DamagePerShot { get; private set; }
        public float Range { get; private set; }

        private int shotsFiredInBurst = 0;
        private float burstCooldown = 0.35f; // time between shots in a burst
        private float burstTimer = 0f;

        public LAAA()
        {
            Name = "LAAA";
            Cooldown = 2.5f; // time between bursts
            BurstCount = 3;
            DamagePerShot = 25;
            Range = 120f;
        }

        public override void Fire(Target target)
        {
            if (!CanFire)
            {
                Console.WriteLine($"{Name} cannot start burst yet ({timeUntilReady:F2}s).");
                return;
            }

            if (!target.IsAirborne)
            {
                Console.WriteLine($"{Name} prefers airborne targets; it's less effective on ground targets.");
            }

            // Start a burst
            shotsFiredInBurst = 0;
            burstTimer = 0f;
            timeUntilReady = Cooldown; // set main cooldown now (can't start another burst)
            Console.WriteLine($"{Name} begins burst at target {target.Position}.");
        }

        public override void Update(float deltaTime)
        {
            base.Update(deltaTime);

            // If a burst is in progress, shoot at burst intervals
            if (timeUntilReady < Cooldown - 0.0001f) // crude way to check if we started a burst earlier
            {
                // we want to fire internal shots if shotsFiredInBurst < BurstCount
                burstTimer -= deltaTime;
                if (burstTimer <= 0f && shotsFiredInBurst < BurstCount)
                {
                    // simulate a shot
                    shotsFiredInBurst++;
                    burstTimer = burstCooldown;
                    Console.WriteLine($"{Name} burst shot {shotsFiredInBurst}/{(int)BurstCount} deals {DamagePerShot} damage.");
                    // In a real system you'd apply damage to the tracked target
                }
            }
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            var weapons = new List<IWeapon>
            {
                new Missile(),
                new Laser(),
                new LAAA()
            };

            var airborneTarget = new Target(new Vector2(100, 200), airborne: true);
            var groundTarget = new Target(new Vector2(50, 10), airborne: false);

            float tick = 0.1f; // 100 ms per update tick
            float simTime = 0f;
            float maxSim = 6.0f;

            Console.WriteLine("=== Weapon simulation start ===");

            while (simTime < maxSim)
            {
                Console.WriteLine($"\n--- t={simTime:F1}s ---");

                // Example firing logic:
                if (Math.Abs(simTime - 0.0f) < 0.001f)
                {
                    weapons[0].Fire(groundTarget); // missile at ground
                    weapons[1].Fire(groundTarget); // laser at ground
                    weapons[2].Fire(airborneTarget); // LAAA at airborne target (burst)
                }

                // Attempt repeated fire to show cooldown behavior
                if (Math.Abs(simTime - 1.0f) < 0.001f)
                {
                    weapons[0].Fire(airborneTarget); // missile again
                }

                // Update all weapons
                foreach (var w in weapons)
                    w.Update(tick);

                Thread.Sleep((int)(tick * 1000)); // slow down console output so you can read it
                simTime += tick;
            }

            Console.WriteLine("\n=== Simulation end ===");
        }
    }
}

//I hope this lowk helps